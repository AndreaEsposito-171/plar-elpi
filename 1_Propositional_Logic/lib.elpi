%%% ===========================================================================
%%% Miscellanea.
%%% ===========================================================================

%%% ---------------------------------------------------------------------------
%%% Boolean connectives.
%%% ---------------------------------------------------------------------------

pred negb o:bool, o:bool.
negb tt ff.
negb ff tt.

pred andb o:bool, o:bool, o:bool.
andb tt tt tt.
andb ff _B ff.
andb _B ff ff.

pred orb o:bool, o:bool, o:bool.
orb ff ff ff.
orb tt _B tt.
orb _B tt tt.

pred impb o:bool, o:bool, o:bool.
impb _B tt tt.
impb ff _B tt.
impb tt ff ff.

pred iffb o:bool, o:bool, o:bool.
iffb tt tt tt.
iffb ff ff tt.
iffb ff tt ff.
iffb tt ff ff.

pred reflect i:prop, o:bool.
reflect P tt :- P, !.
reflect _ ff.

%%% ---------------------------------------------------------------------------
%%% Boolean operations on lists.
%%% ---------------------------------------------------------------------------

pred forallb i:list A, i:(A->bool->pred), o:bool.
forallb [] _F tt.
forallb [X|Xs] F B :- F X tt, !, forallb Xs F B.
forallb _Xs _F ff.

pred existsb i:list A, i:(A->bool->pred), o:bool.
existsb [] _F ff.
existsb [X|_] F tt :- F X tt, !.
existsb [_|Xs] F B :- existsb Xs F B.

pred std.exists! i:list A, i:(A -> prop).
std.exists! [X|_] P :- P X, !.
std.exists! [_|L] P :- std.exists! L P.

%%% ---------------------------------------------------------------------------
%%% Set-like operations on lists.
%%% ---------------------------------------------------------------------------

pred insert i:A, i:list A, o:list A.
insert A L L :- std.mem L A, !.
insert A L [A|L].

pred union i:list A, i:list A, o:list A.
union [] L L.
union [A|L1] L2 L3 :- union L1 {insert A L2} L3.

%%% ---------------------------------------------------------------------------
%%% Nonlogical pridicates.
%%% ---------------------------------------------------------------------------

pred findall i:prop, o:list prop.
findall P L :- new_safe F, findall.aux P F, open_safe F L.
findall.aux P F :- P, stash_in_safe F P, fail.
findall.aux _ _.

%%% ---------------------------------------------------------------------------
%%% Rudimentary testing framework.
%%% ---------------------------------------------------------------------------

kind test type.
type ok, ko prop -> test.
type okb, kob (bool -> prop) -> test.
type ok_eq A -> (A -> prop) -> test.
type report string -> test.

pred run_tests i:(list test).
run_tests Tests :-
       print "run_tests: Start." ,
       run_tests_iter Tests 0 0 S 0 N,
       print "Passed" S "out of" N.

pred run_tests_iter i:(list test), i:int, i:int, o:int, i:int, o:int.
% run_tests_iter Tests I S S1 N N1.
% N : tot num of tests (do not count report).
% I : index of the test.
% S : num successes.
run_tests_iter [] _I S S N N :- print "run_tests: Done!".
run_tests_iter [T|Ts] I S S2 N N2 :-
       run_test T I S S1 N N1, !,
       J is I + 1,
       run_tests_iter Ts J S1 S2 N1 N2.
run_tests_iter [T|_] _I _S _S1 _N _N1 :-
       std.fatal-error-w-data "Unknown test type" T.

pred run_test i:test, i:int, i:int, o:int, i:int, o:int.
run_test (report Msg) _I S S  N N  :- print Msg.
run_test (ok P)        I S S1 N N1 :- N1 is N + 1, test_ok P I S S1.
run_test (ko P)        I S S1 N N1 :- N1 is N + 1, test_ko P I S S1.
run_test (okb P)       I S S1 N N1 :- N1 is N + 1, test_okb P I S S1.
run_test (kob P)       I S S1 N N1 :- N1 is N + 1, test_kob P I S S1.
run_test (ok_eq R P)   I S S1 N N1 :- N1 is N + 1, test_ok_eq R P I S S1.

pred test_ok i:prop, i:int, i:int, o:int.
test_ok P I S S1 :- print I "Test ok:" P, P, !,
                    S1 is S + 1, print I "Exit ok:" P.
test_ok P I S S  :- print "  !!! TEST OK FAILED:" I, print P.

pred test_ko i:prop, i:int, i:int, o:int.
test_ko P I S S  :- print I "Test ko:" P,
                    P, !,
                    print "  !!! TEST KO FAILED:" I, print P.
test_ko P I S S1 :- S1 is S + 1, print I "Exit ko:" P.

pred equal i:A, i:A.
equal A A.

pred test_okb i:(bool -> prop), i:int, i:int, o:int.
test_okb P I S S1 :-
       print I "Test okb:" P,
       sigma X\ P X, !,
       if (equal tt X)
              (S1 is S + 1,
               print I "Exit okb:" P)
              (S1 is S,
               print "  !!! TEST OKB FAILED:" I,
               print "  !!! Term:" P,
               print "  !!! Returned ff").
test_okb P I S S :-
       print "  !!! TEST OKB FAILED:" I,
       print "  !!! Term:" P,
       print "  !!! FAILED".

pred test_kob i:(bool -> prop), i:int, i:int, o:int.
test_kob P I S S1 :-
       print I "Test kob:" P,
       sigma X\ P X, !,
       if (equal ff X)
              (S1 is S + 1,
               print I "Exit kob:" P)
              (S1 is S,
               print "  !!! TEST KOB FAILED:" I,
               print "  !!! Term:" P,
               print "  !!! Returned tt").
test_kob P I S S :-
       print "  !!! TEST KOB FAILED:" I,
       print "  !!! Term:" P,
       print "  !!! FAILED".

pred test_ok_eq i:A, i:(A -> prop), i:int, i:int, o:int.
test_ok_eq R P I S S1 :-
       print I "Test ok eq:" (P R),
       sigma X\ P X, !,
       if (equal R X)
              (S1 is S + 1,
               print I "Exit ok eq:" (P R))
              (S1 is S,
               print "  !!! TEST OK EQ FAILED:" I,
               print "  !!! Expected:" (P R),
               print "  !!! Obtained:" (P X)).
test_ok_eq R P I S S :-
       print "  !!! TEST OK EQ FAILED:" I,
       print "  !!! Expected:" (P R),
       print "  !!! FAILED".
