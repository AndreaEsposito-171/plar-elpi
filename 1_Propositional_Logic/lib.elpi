%%% ===========================================================================
%%% Miscellanea.
%%% ===========================================================================

%%% ---------------------------------------------------------------------------
%%% Boolean connectives.
%%% ---------------------------------------------------------------------------

pred negb o:bool, o:bool.
negb tt ff.
negb ff tt.

pred andb o:bool, o:bool, o:bool.
andb tt tt tt.
andb ff _B ff.
andb _B ff ff.

pred orb o:bool, o:bool, o:bool.
orb ff ff ff.
orb tt _B tt.
orb _B tt tt.

pred impb o:bool, o:bool, o:bool.
impb _B tt tt.
impb ff _B tt.
impb tt ff ff.

pred iffb o:bool, o:bool, o:bool.
iffb tt tt tt.
iffb ff ff tt.
iffb ff tt ff.
iffb tt ff ff.

pred reflect i:prop, o:bool.
reflect P tt :- P, !.
reflect _ ff.

%%% ---------------------------------------------------------------------------
%%% Boolean operations on lists.
%%% ---------------------------------------------------------------------------

pred forallb i:list A, i:(A->bool->pred), o:bool.
forallb [] _F tt.
forallb [X|Xs] F B :- F X tt, !, forallb Xs F B.
forallb _Xs _F ff.

pred existsb i:list A, i:(A->bool->pred), o:bool.
existsb [] _F ff.
existsb [X|_] F tt :- F X tt, !.
existsb [_|Xs] F B :- existsb Xs F B.

pred std.exists! i:list A, i:(A -> prop).
std.exists! [X|_] P :- P X, !.
std.exists! [_|L] P :- std.exists! L P.

%%% ---------------------------------------------------------------------------
%%% Set-like operations on lists.
%%% ---------------------------------------------------------------------------

pred insert i:A, i:list A, o:list A.
insert A L L :- std.mem L A, !.
insert A L [A|L].

pred union i:list A, i:list A, o:list A.
union [] L L.
union [A|L1] L2 L3 :- union L1 {insert A L2} L3.

%% ----------------------------------------------------------------------------
%% Verbosity.
%% ----------------------------------------------------------------------------

pred verbose o:bool.
verbose tt.

pred when-verbose i:prop.
when-verbose _ :- verbose ff, !.
when-verbose P :- P.

pred with-verbosity i:bool, i:prop.
with-verbosity B P :- (verbose B :- !) => P.

%%% ---------------------------------------------------------------------------
%%% Rudimentary testing framework.
%%% ---------------------------------------------------------------------------

namespace testing {

kind test, result, test-stats type.
type test-stats int -> int -> test-stats. % (N, S) = (total, success). 
type success, failure, ignore string -> result.
type section string -> test.
type ok, ko prop -> test.
type okb, kob (bool -> prop) -> test.
type ok-eq A -> (A -> prop) -> test.

pred run-test i:test, o:result.
run-test (section Msg) (ignore "Section title.") :- print "Section:" Msg.
run-test (ok P) (success "") :- P, !.
run-test (ok _) (failure "").
run-test (ko P) (failure "Should fail.") :- P, !.
run-test (ko _) (success "Call fails, as expected.").
run-test (ok-eq A P) Ret :- P Out, !,
    if (equal Out A)
       (Ret = success "")
       (Ret = failure "Wrong return value.").
run-test (ok-eq _ _) (failure "No solution found.").
run-test (okb P) Ret :-
    sigma X\ P X, !,
    % Todo: what if X is flexible?
    if (equal tt X)
       (Ret = success "")
       (Ret = failure "Returned ff.").
run-test (okb _) (failure "No solution found.").
run-test (kob P) Ret :-
    sigma X\ P X, !,
    % Todo: what if X is flexible?
    if (equal ff X)
       (Ret = success "")
       (Ret = failure "Returned tt.").
run-test (kob _) (failure "No solution found.").

pred report-test i:result, i:test-stats, o:test-stats.
report-test (failure Msg) (test-stats Num Succ) (test-stats Num1 Succ) :-
    Num1 is Num + 1,
    print "!! FAILURE: Test number" Num1,
    print_reason Msg.
report-test (success Msg) (test-stats Num Succ) (test-stats Num1 Succ1) :-
    Num1 is Num + 1,
    Succ1 is Succ + 1,
    when-verbose (
        print "   SUCCESS: Test number" Num1,
        print_reason Msg
    ).
report-test (ignore Msg) S S :-
    when-verbose (print "   IGNORE:" Msg).

pred print_reason i:string.
print_reason "".
print_reason Msg :-
    print "   Reason:" Msg.

pred run_tests i:(list test).
run_tests Tests :-
    when-verbose (print "run_tests: Start.") ,
    run_tests_iter Tests (test-stats 0 0) (test-stats S N),
    when-verbose (print "run_tests: Done!"),
    print "Passed" S "out of" N.

pred run_tests_iter i:(list test), i:test-stats, o:test-stats.
run_tests_iter [] S S.
run_tests_iter [T|Ts] S S2 :-
    run_test_item T S S1, !,
    run_tests_iter Ts S1 S2.
run_tests_iter [T|_] _ _ :-
    std.fatal-error-w-data "Unknown test type" T.

pred run_test_item i:test, i:test-stats, o:test-stats.
run_test_item T S S1 :-
    when-verbose (print "-- Test:" T),
    run-test T R, !,
    report-test R S S1,
    when-verbose (print "   Exit:" T).

% To be removed when same_term will be available.
pred equal i:A, i:A.
equal A A.

}