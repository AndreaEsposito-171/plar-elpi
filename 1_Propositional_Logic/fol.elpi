%%% ===========================================================================
%%% First-order logic.
%%% ===========================================================================

accumulate "prop".

%%% ---------------------------------------------------------------------------
%%% Syntax and semantics of terms.
%%% ---------------------------------------------------------------------------

% Terms.
kind term type.

% Composed terms (combinations).
:index(1 1)
pred combination o:term, o:string, o:list term.

% Mapping on terms.
pred copy_term i:term, o:term.
copy_term X Y :- combination X S Xs, !,
                 std.map Xs copy_term Ys,
                 combination Y S Ys.

% Evaluation of functors.
pred funcval i:string, i:list A, o:A.
:if "DBG:HOLDS"
funcval S Vs V :- print "Enter:" (funcval S Vs V), fail.

% Evaluation of terms (recursive).
pred termval i:term, o:A.
:if "DBG:HOLDS"
termval X V :- print "Enter:" (termval X V), fail.
termval X V :- combination X S Xs, funcval S {std.map Xs termval} V.

%%% ---------------------------------------------------------------------------
%%% Syntax of formulas.
%%% ---------------------------------------------------------------------------

% Quantifiers.
type all, ex (term -> formula) -> formula.

% Atomic formulas.
:index(1 1)
pred relation o:formula, o:string, o:list term.

% Closed formulas.
kind formula/c type.
type formula/c formula -> formula/c.
type ctx (term -> formula/c) -> formula/c.

% Mapping on formulas.
copy_formula (all P) (all P1) :- !,
    pi x\ copy_term x x => copy_formula (P x) (P1 x).
copy_formula (ex P) (ex P1) :- !,
    pi x\ copy_term x x => copy_formula (P x) (P1 x).
copy_formula R T :- relation R S Xs, !,
                    std.map Xs copy_term Ys,
                    relation T S Ys.

% Interpretation of atomic formulas.
pred relholds i:string, i:list A, o:bool.
:if "DBG:HOLDS"
relholds S Vs B :- print "Enter:" (relholds S Vs B), fail.

eval P B :- relation P S Xs, !,
            relholds S {std.map Xs termval} B.

pred std.exists! i:list A, i:(A -> prop).
std.exists! [X|_] P :- P X, !.
std.exists! [_|L] P :- std.exists! L P.

pred is_true i:formula.
:if "DBG:HOLDS"
is_true P :- print "Enter:" (is_true P), fail.
is_true P :- eval P tt.


pred holds i:formula, i:list A, o:bool.
:if "DBG:HOLDS"
holds P D B :- print "Enter:" (holds P D B), fail.
holds P D B :-
    [ (pi p\ eval (all p) B :- !,
         pi c \
           reflect (std.forall  D (X \ (termval c X :- !) => is_true (p c)))
                   B)
    , (pi p\ eval (ex  p) B :- !,
         pi c \ reflect (std.exists! D (X \ (termval c X :- !) => is_true (p c)))
                        B)
    ] => eval P B.

pred holds/c i:formula/c, i:list A, o:bool.
holds/c (formula/c P) D B :- holds P D B.
holds/c (ctx P) D B :-
    pi c \
      reflect (std.forall D (X \ (termval c X :- !) => holds/c (P c) D tt))
              B.
