%%% ===========================================================================
%%% First-order logic.
%%% ===========================================================================

accumulate "prop".

% Terms.
kind term type.

pred copy_term i:term, o:term.

% Quantifiers.
type all, ex (term -> formula) -> formula.

% Closed formulas.
kind formula/c type.
type formula/c formula -> formula/c.
type ctx (term -> formula/c) -> formula/c.

% Mapping on formulas.
copy_formula (all P) (all P1) :- !,
    pi x\ copy_term x x => copy_formula (P x) (P1 x).
copy_formula (ex P) (ex P1) :- !,
    pi x\ copy_term x x => copy_formula (P x) (P1 x).

pred is_true i:formula.
:if "DBG:HOLDS"
is_true P :- print "Enter:" (is_true P), fail.
is_true P :- eval P tt.

%%% ---------------------------------------------------------------------------
%%% Interpretation of term and formulas.
%%% ---------------------------------------------------------------------------

pred domain o:list A.

pred holds i:formula, o:bool.
:if "DBG:HOLDS"
holds P B :- print "Enter:" (holds P B), fail.
holds P B :-
    [ (pi p\ eval (all p) B :- !,
         pi c\ sigma D\ domain D,
           reflect (std.forall D
                      (X \ (termval c X :- !) => is_true (p c)))
                   B)
    , (pi p\ eval (ex  p) B :- !,
         pi c\ sigma D\ domain D,
           reflect (std.exists! D
                      (X \ (termval c X :- !) => is_true (p c)))
                   B)
    ] => eval P B.

pred holds/c i:formula/c, o:bool.
holds/c (formula/c P) B :- holds P B.
holds/c (ctx P) B :-
    pi c \ sigma D\ domain D,
      reflect (std.forall D
                 (X \ (termval c X :- !) => holds/c (P c) tt))
              B.
