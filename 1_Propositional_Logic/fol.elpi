%%% ===========================================================================
%%% First-order logic.
%%% ===========================================================================

accumulate "prop".

%%% ---------------------------------------------------------------------------
%%% Syntax.
%%% ---------------------------------------------------------------------------

kind term type.

% Quantifiers.
type all, ex (term -> formula) -> formula.

% Terms and atomic formulas.
type fn string -> list term -> term.
type rel string -> list term -> formula.

atomic (rel _ _).

% Closed formulas.
kind formula/c type.
type formula/c formula -> formula/c.
type ctx (term -> formula/c) -> formula/c.

%%% ---------------------------------------------------------------------------
%%% Basic iteration.
%%% ---------------------------------------------------------------------------

pred copy_term i:term, o:term.
copy_term (fn S Xs) (fn S Ys) :- !, std.map Xs copy_term Ys.

copy_formula (rel S Xs) (rel S Ys) :- !,
    std.map Xs copy_term Ys.
copy_formula (all P) (all P1) :- !,
    pi x\ copy_term x x => copy_formula (P x) (P1 x).
copy_formula (ex P) (ex P1) :- !,
    pi x\ copy_term x x => copy_formula (P x) (P1 x).

%%% ---------------------------------------------------------------------------
%%% Interpretations and semantics.
%%% ---------------------------------------------------------------------------

pred funcval i:string, i:list A, o:A.
:if "DBG:HOLDS"
funcval S Vs V :- print "Enter:" (funcval S Vs V), fail.

pred termval i:term, o:A.
:if "DBG:HOLDS"
termval X V :- print "Enter:" (termval X V), fail.
termval (fn S Xs) V :- funcval S {std.map Xs termval} V.

pred relholds i:string, i:list A.
:if "DBG:HOLDS"
relholds S Vs :- print "Enter:" (relholds S Vs), fail.

eval (rel S Xs) B :- !, reflect (relholds S {std.map Xs termval}) B.

pred std.exists! i:list A, i:(A -> prop).
std.exists! [X|_] P :- P X, !.
std.exists! [_|L] P :- std.exists! L P.

pred is_true i:formula.
:if "DBG:HOLDS"
is_true P :- print "Enter:" (is_true P), fail.
is_true P :- eval P tt.


pred holds i:formula, i:list A.
:if "DBG:HOLDS"
holds P D :- print "Enter:" (holds P D), fail.
holds P D :-
    [ (pi p\ eval (all p) tt :- !,
         pi c \ std.forall  D (X \ (termval c X :- !) => is_true (p c)))
    , (pi p\ eval (ex  p) tt :- !,
         pi c \ std.exists! D (X \ (termval c X :- !) => is_true (p c)))
    , (eval (all _) ff :- !)
    , (eval (ex  _) ff :- !)
    ] => is_true P.

pred holds/c i:formula/c, i:list A.
holds/c (formula/c P) D :- holds P D.
holds/c (ctx P) D :-
    pi c\ std.forall D (X \ (termval c X :- !) => holds/c (P c) D).
