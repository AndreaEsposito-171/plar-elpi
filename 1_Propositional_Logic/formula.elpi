%%% ===========================================================================
%%% Chapter 2: Propositional logic
%%% ===========================================================================

accumulate "lib".

%%% ---------------------------------------------------------------------------
%%% Datatype for formulas.
%%% ---------------------------------------------------------------------------

kind formula type.
type falsity, truth formula.
type neg formula -> formula.
type &&, !!, ==>, <=> formula -> formula -> formula.
type atom string -> formula.

infixl !!  4.
infixl &&  5.
infixr ==> 6.
infixr <=> 6.

%%% ---------------------------------------------------------------------------
%%% Basic manipulation procedures.
%%% ---------------------------------------------------------------------------

pred dest_and i:formula, o:formula, o:formula.
dest_and (P && Q) P Q.

pred conjuncts i:formula, o:list formula.
conjuncts (P && Q) L :- !, std.append {conjuncts P} {conjuncts Q} L.
conjuncts P [P].

pred dest_or i:formula, o:formula, o:formula.
dest_or (P !! Q) P Q.

pred disjuncts i:formula, o:list formula.
disjuncts (P !! Q) L :- !, std.append {disjuncts P} {disjuncts Q} L.
disjuncts P [P].

pred dest_imp i:formula, o:formula, o:formula.
dest_imp (P ==> Q) P Q.

pred antecedent i:formula, o:formula.
antecedent (P ==> _Q) P.

pred consequent i:formula, o:formula.
consequent (_P ==> Q) Q.

%%% ---------------------------------------------------------------------------
%%% Basic iteration.
%%% ---------------------------------------------------------------------------

pred copy_formula i:formula, o:formula.
copy_formula (neg P)   (neg P1)    :- !, copy_formula P P1.
copy_formula (P &&  Q) (P1 &&  Q1) :- !, copy_formula P P1, copy_formula Q Q1.
copy_formula (P !!  Q) (P1 !!  Q1) :- !, copy_formula P P1, copy_formula Q Q1.
copy_formula (P <=> Q) (P1 <=> Q1) :- !, copy_formula P P1, copy_formula Q Q1.
copy_formula (P ==> Q) (P1 ==> Q1) :- !, copy_formula P P1, copy_formula Q Q1.
copy_formula P P.

pred onatoms i:(string -> string -> o), i:formula, o:formula.
onatoms F P Q :-
    (pi S\ pi T\ [F S T, !] => copy_formula (atom S) (atom T))
    => copy_formula P Q.

pred fold i:formula, i:A, o:A.
fold   (neg P) A A1 :- !, fold P A A1.
fold (P && Q) A A1 :- !, fold Q A B, fold P B A1.
fold (P !!  Q) A A1 :- !, fold Q A B, fold P B A1.
fold (P ==> Q) A A1 :- !, fold Q A B, fold P B A1.
fold (P <=> Q) A A1 :- !, fold Q A B, fold P B A1.
fold _P A A.

pred overatoms i:(string -> A -> A -> o), i:formula, i:A, o:A.
overatoms F P A A1 :-
    (pi S\ pi A\ pi A1\ fold (atom S) A A1 :- F S A A1, !)
    => fold P A A1.

pred atom_union i:(string -> list A -> o), i:formula, o:list A.
atom_union F P L :-
    (pi S\ pi L\ pi L1\ pi M\
       fold (atom S) L L1 :- F S M, !, union M L L1)
    => fold P [] L.
