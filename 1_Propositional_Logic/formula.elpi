%%% ===========================================================================
%%% Chapter 2: Propositional logic
%%% ===========================================================================

accumulate "lib".

%%% ---------------------------------------------------------------------------
%%% Datatype for formulas.
%%% ---------------------------------------------------------------------------

kind formula type.
type falsity, truth formula.
type neg formula -> formula.
type &&, !!, ==>, <=> formula -> formula -> formula.

infixl !!  4.
infixl &&  5.
infixr ==> 6.
infixr <=> 6.

%%% ---------------------------------------------------------------------------
%%% Basic manipulation procedures.
%%% ---------------------------------------------------------------------------

pred dest_and i:formula, o:formula, o:formula.
dest_and (P && Q) P Q.

pred conjuncts i:formula, o:list formula.
conjuncts (P && Q) L :- !, std.append {conjuncts P} {conjuncts Q} L.
conjuncts P [P].

pred dest_or i:formula, o:formula, o:formula.
dest_or (P !! Q) P Q.

pred disjuncts i:formula, o:list formula.
disjuncts (P !! Q) L :- !, std.append {disjuncts P} {disjuncts Q} L.
disjuncts P [P].

pred dest_imp i:formula, o:formula, o:formula.
dest_imp (P ==> Q) P Q.

pred antecedent i:formula, o:formula.
antecedent (P ==> _Q) P.

pred consequent i:formula, o:formula.
consequent (_P ==> Q) Q.

%%% ---------------------------------------------------------------------------
%%% Basic iteration.
%%% ---------------------------------------------------------------------------

pred copy_formula i:formula, o:formula.
copy_formula     truth       truth :- !.
copy_formula   falsity     falsity :- !.
copy_formula   (neg P)    (neg P1) :- !, copy_formula P P1.
copy_formula (P &&  Q) (P1 &&  Q1) :- !, copy_formula P P1, copy_formula Q Q1.
copy_formula (P !!  Q) (P1 !!  Q1) :- !, copy_formula P P1, copy_formula Q Q1.
copy_formula (P <=> Q) (P1 <=> Q1) :- !, copy_formula P P1, copy_formula Q Q1.
copy_formula (P ==> Q) (P1 ==> Q1) :- !, copy_formula P P1, copy_formula Q Q1.

%%% ---------------------------------------------------------------------------
%%% Accumulating on all subformulas of a formula.
%%% ---------------------------------------------------------------------------

pred fold i:formula, i:A, o:A.
fold     truth A A  :- !.
fold   falsity A A  :- !.
fold   (neg P) A A1 :- !, fold P A A1.
fold (P &&  Q) A A1 :- !, fold Q A B, fold P B A1.
fold (P !!  Q) A A1 :- !, fold Q A B, fold P B A1.
fold (P ==> Q) A A1 :- !, fold Q A B, fold P B A1.
fold (P <=> Q) A A1 :- !, fold Q A B, fold P B A1.

%%% ---------------------------------------------------------------------------
%%% Non atomic formulas.
%%% We will add new clauses to this predicate when we extend the syntax to
%%% predicate logic and introduce quantifiers.
%%% ---------------------------------------------------------------------------

pred nonatomic i:formula.
nonatomic   (neg _).
nonatomic (_ &&  _).
nonatomic (_ !!  _).
nonatomic (_ <=> _).
nonatomic (_ ==> _).

%%% ---------------------------------------------------------------------------
%%% Atomic formulas.
%%% Intuitively, this should be the negation of the predicate nonatomic above.
%%% However, this predicate is introduced here with no clauses.
%%% Clauses for this predicate will be added locally when needed.
%%% ---------------------------------------------------------------------------

pred atomic i:formula.

%%% ---------------------------------------------------------------------------
%%% Mapping on atoms.
%%% ---------------------------------------------------------------------------

pred onatoms i:(formula -> formula -> o), i:formula, o:formula.
onatoms F P Q :-
    (pi A\ pi B\ copy_formula A B :- atomic A, !, F A B)
    => copy_formula P Q.

%%% ---------------------------------------------------------------------------
%%% Collecting atoms.
%%% ---------------------------------------------------------------------------

pred atoms i:formula, o:list formula.
atoms P L :-
    (pi A\ pi L\ pi L1\ fold A L L1 :- atomic A, !, insert A L L1)
    => fold P [] L.
