%%% ===========================================================================
%%% Mod 3 interpretation.
%%% ===========================================================================

accumulate "fol".

%%% ---------------------------------------------------------------------------
%%% Model.
%%% ---------------------------------------------------------------------------

% pred domain i:list int.
domain [0,1,2].

pred mul3 i:int, i:int, o:int.
mul3 0 N 0 :- !.
mul3 N 0 0 :- !.
mul3 1 N N :- !.
mul3 N 1 N.
mul3 2 2 1.

pred eq3 i:int, i:int, o:bool.
eq3 N N tt :- domain D, std.mem D N, !.
eq3 M N ff :- domain D, std.mem D M, std.mem D N.

%%% ---------------------------------------------------------------------------
%%% Language.
%%% ---------------------------------------------------------------------------

type zero, one, two term.
type add, mul term -> term -> term.
type eq term -> term -> formula.

%%% ---------------------------------------------------------------------------
%%% Interpretation.
%%% ---------------------------------------------------------------------------

pred termval i:term, o:int.
termval zero 0.
termval one  1.
termval two  2.
termval (add X Y) N :- N is ({termval X} + {termval Y}) mod 3.
termval (mul X Y) N :- N is ({termval X} * {termval Y}) mod 3.

eval (eq X Y) B :- reflect (0 is ({termval X} - {termval Y}) mod 3) B.

%%% ---------------------------------------------------------------------------
%%% Tests.
%%% ---------------------------------------------------------------------------

main :-
    run_tests
    [ report "Mod 3"
    , ok_eq tt (holds (ex X\ eq (add two one) zero))
    , ok_eq ff (holds (ex X\ eq (add two two) zero))
    , ok_eq tt (holds (ex X\ eq (add X one) two))
    , ok_eq tt (holds (all X\ eq (mul X zero) zero))
    , ok_eq ff (holds (ex X\ eq (mul X zero) one))
    ].
