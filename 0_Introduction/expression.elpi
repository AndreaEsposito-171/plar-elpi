%%% =========================================================================== 
%%% Chapter 1. Introduction
%%% 
%%%    Section 1.6: Symbolic expressions in OCaml
%%% 
%%%    ToDo:
%%%      - Parser and support for concrete syntax?
%%%      - Use of arithmetic operators +, * : is it possible?    
%%%      - Priority of "add", "mul" ?
%%%      - More tests?
%%%      - Is varb needed?  Use lProlog variables?                                                       
%%% ===========================================================================

%% ----------------------------------------------------------------------------
%% Datatype for expressions.
%% ----------------------------------------------------------------------------

kind expression type.
type const int -> expression.
type add expression -> expression -> expression.
type mul expression -> expression -> expression.

infixl add 6.
infixl mul 7.

pred simplify1 i:expression, o:expression.

simplify1 (const M add const N) (const P) :- P is M + N, !.
simplify1 (const M mul const N) (const P) :- P is M * N, !.
simplify1 (const 0 add X) X :- !.
simplify1 (X add const 0) X :- !.
simplify1 (const 0 mul _) (const 0) :- !.
simplify1 (_ mul const 0) (const 0) :- !.
simplify1 (const 1 mul X) X :- !.
simplify1 (X mul const 1) X :- !.
simplify1 X X.

pred simplify i:expression, o:expression.
simplify (E1 add E2) E :- !, simplify1 ({simplify E1} add {simplify E2}) E.
simplify (E1 mul E2) E :- !, simplify1 ({simplify E1} mul {simplify E2}) E.
simplify E E.

%%% ---------------------------------------------------------------------------
%%% Mapping.
%%% ---------------------------------------------------------------------------

pred copy i:expression, o:expression.
copy (const N) (const N).
copy (X add Y) (X1 add Y1) :- copy X X1, copy Y Y1.
copy (X mul Y) (X1 mul Y1) :- copy X X1, copy Y Y1.

pred copy1 i:expression, o:expression.
copy1 X X.
% copy1 (const N) (const N).
% copy1 (X add Y) (X add Y).
% copy1 (X mul Y) (X mul Y).

pred deepcopy i:expression, o:expression.
deepcopy (const N) (const N).
deepcopy (X add Y) Z :- copy1 ({deepcopy X} add {deepcopy Y}) Z.
deepcopy (X mul Y) Z :- copy1 ({deepcopy X} mul {deepcopy Y}) Z.

%%% ---------------------------------------------------------------------------
%%% Compositional simplification.
%%% ---------------------------------------------------------------------------

pred copy_comp i:expression, o:expression.
copy_comp (const M add const N) (const P) :- P is M + N, !.
copy_comp (const M mul const N) (const P) :- P is M * N, !.

pred copy_add_zero i:expression, o:expression.
copy_add_zero (const 0 add X) X :- !.
copy_add_zero (X add const 0) X :- !.

pred copy_mul_one i:expression, o:expression.
copy_mul_one (const 1 mul X) X :- !.
copy_mul_one (X mul const 1) X :- !.

pred copy_mul_zero i:expression, o:expression.
copy_mul_zero (const 0 mul _X) (const 0) :- !.
copy_mul_zero (_X mul const 0) (const 0) :- !.

pred simpl0 i:expression, o:expression.
simpl0 X X1 :-
    (pi X X1 \ copy X X1 :- copy_mul_zero X X1, !)
    => copy X X1.

pred deepsimpl0 i:expression, o:expression.
deepsimpl0 X X1 :-
    (pi X X1 \ copy1 X X1 :- copy_mul_zero X X1, !)
    => deepcopy X X1.

pred compute i:expression, o:expression.
compute X X1 :-
    (pi X X1 \ copy1 X X1 :- copy_comp X X1, !)
    => deepcopy X X1.

pred topcompute i:expression, o:expression.
topcompute X X1 :-
    (pi X X1 \ copy X X1 :- copy_comp X X1, !)
    => copy X X1.

%%% ---------------------------------------------------------------------------
%%% Run tests.
%%% ---------------------------------------------------------------------------

main :-
    std.spy(simplify (const 0 add const 1) _E1), !,
    std.spy(pi X\ simplify
              ((const 0 mul X add const 1) mul const 3 add const 12)
              E2),
    !, print E2,
    MINUSONE is 0 - 1,
    std.spy(simpl0 ((const 1 mul (const 0 mul const 0))
                    add
                    (const 2 mul (const MINUSONE add const 1)))
                  E3),
    !, print E3,
    std.spy(deepsimpl0 ((const 1 mul (const 0 mul const 0))
                        add
                        (const 2 mul (const MINUSONE add const 1)))
                  E4),
    !, print E4,
    std.spy(compute ((const 1 mul (const 0 mul const 0))
                        add
                        (const 2 mul (const MINUSONE add const 1)))
                  E5),
    !, print E5,
    std.spy(topcompute ((const 1 mul (const 0 mul const 0))
                        add
                        (const 2 mul (const MINUSONE add const 1)))
                  E6),
    !, print E6.
